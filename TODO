1. Shrinking files
2. Support *Let*/And, or exist/Monadic code...
----------------
-- 1. Haskell style $ 
-- 2. get rid of special infix notation 
3. *smarter* pattern matching ? 
4. prettyprint for infix notaton

5. How to exploit Mogensen's self interpretation? 
    1. represent term as data 
       now we can manipulate these data and interpret them
    2. define an interpreter. 
       But, we can't write the encode function though, 
       which require intensional analyze on meta-lambda term. 
       So a build-in primitive 'quote' is require. 
       quote : pure-lambda-term => LTerm
    3. How this could be helpful without constantly need to extend
       the implementation and making the prog language itself extensible.

--6. How to get a more efficient hnf reduction?
   
   {- Renaming cost, FV cost, membership cost -- the cost of doing *a* substitution
      Y-Theta-cost -- added up with multiple subs. -}
   it doesn't matter, since what we are doing is reasoning, not *actually* runing
   program.

  6. Not planning to let the ghc do the work for us, since
     it is based on primitive data type and explicit typed 
     core. So we would need our own interpretor, then we 
     would need to investigate the techniques needed to optimize
     hn-reduction. 
     
    
   
       
       